use crate::ast::{AstError, ID, UntypedExprKind, UntypedSpExpr, ErrorRecovery, Opcode, Type};
use crate::lexer::Token;
use crate::span::Span;

grammar<'input, 'err>(errors: &'err mut Vec<ErrorRecovery<'input>>);

extern {
    type Error = Span<AstError>;
    type Location = usize;

    enum Token<'input> {
        Number => Token::Num(<&'input str>),
        ID => Token::ID(<&'input str>),
        "+" => Token::Plus,
        "-" => Token::Minus,
        "*" => Token::Multiply,
        "/" => Token::Divide,
        "=" => Token::Eq,
        ";" => Token::Semi,
        "," => Token::Comma,
        "{" => Token::CurlyStart,
        "}" => Token::CurlyEnd,
        "(" => Token::ParenStart,
        ")" => Token::ParenEnd,
        ":" => Token::Colon,
        "if" => Token::If,
        "let" => Token::Let,
        "else" => Token::Else,
        "true" => Token::True,
        "false" => Token::False,
        "int" => Token::Int,
        "bool" => Token::Bool,
    }
}

/// wraps UntypedExprKind in a Span which tracks its location
Sp<Rule>: UntypedSpExpr =
    <l: @L> <rule: Rule> <r: @R> => (l, Box::new(rule.into()), r).into();

// Root of the grammar
pub Program: UntypedSpExpr = {
    Sp<Sequence>
}
pub Sequence: UntypedExprKind = {
    <mut v:MaybeStatements> => {
        // if the program has just one statement, unwrap it.
        if v.len() == 1 {
            (*v.remove(0).item).into()
        } else {
            UntypedExprKind::Block(v)
        }
    }
}

// Statement grammar

// statements optionally followed by one expression
MaybeStatements: Vec<UntypedSpExpr> = {
  Statements,
  <mut v:Statements> <e:Sp<ExpressionWithoutBlock>> => {v.push(e); v},
  Sp<ExpressionWithoutBlock> => vec![<>],
  () => vec![],
};

#[inline]
Statements: Vec<UntypedSpExpr> = {
    Sequence1<Statement>
};

Statement: UntypedExprKind = {
  LetStatement,
  ExpressionStatement,
  //";" => None, // shift-reduce conflict
};

Expression: UntypedExprKind = {
        ExpressionWithBlock,
        ExpressionWithoutBlock,
}
// expressions that act as individual statements with their own delimiters (e.g. curly braces)
ExpressionWithBlock: UntypedExprKind = {
Block,
IfExpr,
}

ExpressionWithoutBlock: UntypedExprKind = {
CallExpression,
ArithmeticOrLogicalExpression,
}

#[inline]
ExpressionStatement: UntypedExprKind = {
    <ExpressionWithoutBlock> ";",
    <ExpressionWithBlock> ";"?,
}

LetStatement: UntypedExprKind = {
    "let" <i:ID> <t:MaybeTyAscription> <e:MaybeInitExpr> ";" => UntypedExprKind::Let(ID::Name(i.to_string()), t, e),
};

Block: UntypedExprKind = {
  "{" <MaybeStatements> "}" => UntypedExprKind::Block(<>),
};

CallExpression: UntypedExprKind = {
    <func:Sp<ExpressionWithoutBlock>> "(" <params:CommaNoTrail<Expression>> ")" =>
       UntypedExprKind::Call(func, params)
}

// Type grammar

MaybeTyAscription: Option<Type> = {
    (":" <TySum>)?
};

MaybeInitExpr: Option<UntypedSpExpr> = {
    ("=" <Sp<Expression>>)?,
};

TySum: Type = {
  ty,
};

ty: Type = {
  TyPrim,
  "(" ")" => Type::Void,
};
TyPrim: Type = {
  "int" => Type::Int64,
  "bool" => Type::Bool,
};

// Expression grammar

/// A single operator expression yields a value and may recurse
ArithmeticOrLogicalExpression : UntypedExprKind = {
    Sp<ExpressionWithoutBlock> ExprOp Sp<Factor> => UntypedExprKind::Op(<>),
    Factor,
};

ExprOp: Opcode = {
    "+" => Opcode::Add,
    "-" => Opcode::Sub,
};

Factor: UntypedExprKind = {
    Sp<Factor> FactorOp Sp<UnaryTerm> => UntypedExprKind::Op(<>),
    UnaryTerm,
    ! => { errors.push(<>.clone()); UntypedExprKind::from_error(&<>) },
};

FactorOp: Opcode = {
    "*" => Opcode::Mul,
    "/" => Opcode::Div,
};

UnaryTerm: UntypedExprKind = {
    "-" <Sp<Term>> => UntypedExprKind::Negate(<>),
    Term,
};

Term: UntypedExprKind = {
    Number => UntypedExprKind::Number(<>.to_string()),
    ID => UntypedExprKind::Identifier(ID::Name(<>.to_string())),
    "true" => UntypedExprKind::Bool(true),
    "false" => UntypedExprKind::Bool(false),
    "(" <Expression> ")",
};

IfExpr: UntypedExprKind = {
    "if" <c:Sp<ExpressionWithoutBlock>> <t:Sp<Block>> "else" <f:Sp<Block>> => UntypedExprKind::If(c, t, f),
}


// Macros for delimited lists

#[inline]
Comma1NoTrail<E>: Vec<UntypedSpExpr> = {
    Delimited1<E, ",">
};

#[inline]
CommaNoTrail<E>: Vec<UntypedSpExpr> = {
    Delimited<E, ",">
};


#[inline]
Delimited<E, D>: Vec<UntypedSpExpr> = {
    Delimited1<E, D>,
    () => vec![],
};


Delimited1<E, D>: Vec<UntypedSpExpr> = {
    <mut v:Delimited1<E, D>> D <e:Sp<E>> => {
        v.push(e);
        v
    },
    Sp<E> => vec![<>],
};

Sequence1<E>: Vec<UntypedSpExpr> = {
    <mut v:Sequence1<E>> <e:Sp<E>> => {
        v.push(e);
        v
    },
    Sp<E> => vec![<>],
};