use crate::ast::{AstError, UntypedExprKind, UntypedSpExpr, ErrorRecovery, Opcode};
use crate::lexer::Token;
use crate::span::Span;

grammar<'input, 'err>(errors: &'err mut Vec<ErrorRecovery<'input>>);

extern {
    type Error = Span<AstError>;
    type Location = usize;

    enum Token<'input> {
        Number => Token::Num(<&'input str>),
        ID => Token::ID(<&'input str>),
        "+" => Token::Plus,
        "-" => Token::Minus,
        "*" => Token::Multiply,
        "/" => Token::Divide,
        ";" => Token::Semi,
        "{" => Token::CurlyStart,
        "}" => Token::CurlyEnd,
        "(" => Token::ParenStart,
        ")" => Token::ParenEnd,
        "if" => Token::If,
        "else" => Token::Else,
        "true" => Token::True,
        "false" => Token::False,
    }
}

/// wraps UntypedExprKind in a Span which tracks its location
Sp<Rule>: UntypedSpExpr =
    <l: @L> <rule: Rule> <r: @R> => (l, Box::new(rule.into()), r).into();

// The root of the grammar
pub Expression: UntypedSpExpr = {
    Sp<Expr>
}

/// The recursive inner Expr production
pub Expr: UntypedExprKind = {
    Sp<Expr> ExprOp Sp<Factor> => UntypedExprKind::Op(<>),
    Factor,
    IfExpr,
};

ExprOp: Opcode = {
    "+" => Opcode::Add,
    "-" => Opcode::Sub,
};

Factor: UntypedExprKind = {
    Sp<Factor> FactorOp Sp<UnaryTerm> => UntypedExprKind::Op(<>),
    UnaryTerm,
    ! => { errors.push(<>.clone()); UntypedExprKind::from_error(&<>) },
};

FactorOp: Opcode = {
    "*" => Opcode::Mul,
    "/" => Opcode::Div,
};

UnaryTerm: UntypedExprKind = {
    "-" <Sp<Term>> => UntypedExprKind::Negate(<>),
    Term,
};

Term: UntypedExprKind = {
    Number => UntypedExprKind::Number(<>.to_string()),
    ID => UntypedExprKind::Identifier(<>.to_string()),
    "true" => UntypedExprKind::Bool(true),
    "false" => UntypedExprKind::Bool(false),
    "(" <Expr> ")",
};

Block: UntypedExprKind = {
    "{" <ExpressionSequence> "}" =>  UntypedExprKind::Block(<>),
};

ExpressionSequence: Vec<UntypedSpExpr> = {
    <mut v:ExpressionSequence> ";" <e:Sp<Expr>> => {
        v.push(e);
        v
    },
    Sp<Expr> => vec![<>],
};

IfExpr: UntypedExprKind = {
    "if" <c:Sp<Expr>> <t:Sp<Block>> "else" <f:Sp<Block>> => UntypedExprKind::If(c, t, f),
}
