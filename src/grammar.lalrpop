use crate::ast::{AstError, ID, UntypedExprKind, UntypedSpExpr, ErrorRecovery, Opcode, Type};
use crate::lexer::Token;
use crate::span::Span;

grammar<'input, 'err>(errors: &'err mut Vec<ErrorRecovery<'input>>);

extern {
    type Error = Span<AstError>;
    type Location = usize;

    enum Token<'input> {
        Number => Token::Num(<&'input str>),
        ID => Token::ID(<&'input str>),
        "+" => Token::Plus,
        "-" => Token::Minus,
        "*" => Token::Multiply,
        "/" => Token::Divide,
        "=" => Token::Eq,
        ";" => Token::Semi,
        "{" => Token::CurlyStart,
        "}" => Token::CurlyEnd,
        "(" => Token::ParenStart,
        ")" => Token::ParenEnd,
        ":" => Token::Colon,
        "if" => Token::If,
        "let" => Token::Let,
        "else" => Token::Else,
        "true" => Token::True,
        "false" => Token::False,
        "int" => Token::Int,
        "bool" => Token::Bool,
    }
}

/// wraps UntypedExprKind in a Span which tracks its location
Sp<Rule>: UntypedSpExpr =
    <l: @L> <rule: Rule> <r: @R> => (l, Box::new(rule.into()), r).into();

// Root of the grammar
pub Program: UntypedSpExpr = {
    Sp<Sequence>
}
pub Sequence: UntypedExprKind = {
    <mut v:MaybeStatements> => {
        // if the program has just one statement, unwrap it.
        if v.len() == 1 {
            (*v.remove(0).item).into()
        } else {
            UntypedExprKind::Block(v)
        }
    }
}

// Statement grammar

MaybeStatements: Vec<UntypedSpExpr> = {
  Statements,
  <mut v:Statements> <e:Sp<Expr>> => {v.push(e); v},
  Sp<Expr> => vec![<>],
  () => vec![],
};

Statements: Vec<UntypedSpExpr> = {
    <mut v:Statements> <e:Sp<Statement>> => {
        v.push(e);
        v
    },
    Sp<Statement> => vec![<>],
};

Statement: UntypedExprKind = {
  Let,
  ExprStmtLike,
  Block,
};

Let: UntypedExprKind = {
    "let" <i:ID> <t:MaybeTyAscription> <e:MaybeInitExpr> ";" => UntypedExprKind::Let(ID::Name(i.to_string()), t, e),
};

Block: UntypedExprKind = {
  "{" <MaybeStatements> "}" => UntypedExprKind::Block(<>),
};

// Type grammar

MaybeTyAscription: Option<Type> = {
    (":" <TySum>)?
};

MaybeInitExpr: Option<UntypedSpExpr> = {
    ("=" <Sp<Expr>>)?,
    ("=" <Sp<IfExpr>>) => Some(<>),
    ("=" <Sp<Block>>) => Some(<>),
};

TySum: Type = {
  ty,
};

ty: Type = {
  TyPrim,
  "(" ")" => Type::Void,
};
TyPrim: Type = {
  "int" => Type::Int64,
  "bool" => Type::Bool,
};

// Expression grammar

// expressions that act as individual statements with their own delimiters (e.g. curly braces)
ExprStmtLike: UntypedExprKind = {
    IfExpr,
    <Expr> ";",
}

/// A single expression yields a value and may recurse
Expr: UntypedExprKind = {
    Sp<Expr> ExprOp Sp<Factor> => UntypedExprKind::Op(<>),
    Factor,
};

ExprOp: Opcode = {
    "+" => Opcode::Add,
    "-" => Opcode::Sub,
};

Factor: UntypedExprKind = {
    Sp<Factor> FactorOp Sp<UnaryTerm> => UntypedExprKind::Op(<>),
    UnaryTerm,
    ! => { errors.push(<>.clone()); UntypedExprKind::from_error(&<>) },
};

FactorOp: Opcode = {
    "*" => Opcode::Mul,
    "/" => Opcode::Div,
};

UnaryTerm: UntypedExprKind = {
    "-" <Sp<Term>> => UntypedExprKind::Negate(<>),
    Term,
};

Term: UntypedExprKind = {
    Number => UntypedExprKind::Number(<>.to_string()),
    ID => UntypedExprKind::Identifier(ID::Name(<>.to_string())),
    "true" => UntypedExprKind::Bool(true),
    "false" => UntypedExprKind::Bool(false),
    "(" <Expr> ")",
};

IfExpr: UntypedExprKind = {
    "if" <c:Sp<Expr>> <t:Sp<Block>> "else" <f:Sp<Block>> => UntypedExprKind::If(c, t, f),
}
