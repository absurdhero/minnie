use crate::ast::{AstError, Expr, ExprKind, ErrorRecovery, Opcode, ParseError, SpExpr};
use crate::lexer::Token;
use crate::span::Span;

grammar<'input, 'err>(errors: &'err mut Vec<ErrorRecovery<'input>>);

extern {
    type Error = Span<AstError>;
    type Location = usize;

    enum Token<'input> {
        Number => Token::Num(<&'input str>),
        ID => Token::ID(<&'input str>),
        "+" => Token::Plus,
        "-" => Token::Minus,
        "*" => Token::Multiply,
        "/" => Token::Divide,
        ";" => Token::Semi,
        "{" => Token::CurlyStart,
        "}" => Token::CurlyEnd,
        "(" => Token::ParenStart,
        ")" => Token::ParenEnd,
        "if" => Token::If,
        "else" => Token::Else,
        "true" => Token::True,
        "false" => Token::False,
    }
}

/// wraps Expr and AstError in a Span which tracks its location
Sp<Rule>: SpExpr =
    <l: @L> <rule: Rule> <r: @R> =>?
        Expr::new(rule).map(|e| (l, e, r).into())
                       .map_err(|err| ParseError::User { error: (l, err, r).into() });


// The root of the grammar
pub Expression: SpExpr = {
    Sp<Expr>
}

/// The recursive inner Expr production
pub Expr: ExprKind = {
    Sp<Expr> ExprOp Sp<Factor> => ExprKind::Op(<>),
    Factor,
    IfExpr,
};

ExprOp: Opcode = {
    "+" => Opcode::Add,
    "-" => Opcode::Sub,
};

Factor: ExprKind = {
    Sp<Factor> FactorOp Sp<UnaryTerm> => ExprKind::Op(<>),
    UnaryTerm,
    ! => { errors.push(<>.clone()); ExprKind::from_error(&<>) },
};

FactorOp: Opcode = {
    "*" => Opcode::Mul,
    "/" => Opcode::Div,
};

UnaryTerm: ExprKind = {
    "-" <Sp<Term>> => ExprKind::Negate(<>),
    Term,
};

Term: ExprKind = {
    Number => ExprKind::Number(<>.to_string()),
    ID => ExprKind::Identifier(<>.to_string()),
    "true" => ExprKind::Bool(true),
    "false" => ExprKind::Bool(false),
    "(" <Expr> ")",
};

Block: ExprKind = {
    "{" <ExpressionSequence> "}" =>  ExprKind::Block(<>),
};

ExpressionSequence: Vec<SpExpr> = {
    <mut v:ExpressionSequence> ";" <e:Sp<Expr>> => {
        v.push(e);
        v
    },
    Sp<Expr> => vec![<>],
};

IfExpr: ExprKind = {
    "if" <c:Sp<Expr>> <t:Sp<Block>> "else" <f:Sp<Block>> => ExprKind::If(c, t, f),
}
