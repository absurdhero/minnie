use crate::ast::{ExprKind, Opcode, Expr, SyntaxError};

grammar;

extern {
    type Error = SyntaxError;
}

/// wraps an ExprKind into an Expr which tracks its type and location
Sp<Rule>: Box<Expr> =
    <l: @L> <rule: Rule> <r: @R> =>?
        Expr::new(rule, l..r);


// The root of the grammar
pub Expression: Box<Expr> = {
    Sp<Expr>
}

/// The recursive inner Expr production
pub Expr: ExprKind = {
    Sp<Expr> ExprOp Sp<Factor> => ExprKind::Op(<>),
    Factor,
    IfExpr,
};

ExprOp: Opcode = {
    "+" => Opcode::Add,
    "-" => Opcode::Sub,
};

Factor: ExprKind = {
    Sp<Factor> FactorOp Sp<UnaryTerm> => ExprKind::Op(<>),
    UnaryTerm,
};

FactorOp: Opcode = {
    "*" => Opcode::Mul,
    "/" => Opcode::Div,
};

UnaryTerm: ExprKind = {
    "-" <Sp<Term>> => ExprKind::Negate(<>),
    Term,
};

Term: ExprKind = {
    Num,
    TRUE,
    FALSE,
    "(" <Expr> ")",
};

Block: ExprKind = {
    "{" <ExpressionSequence> "}" =>  ExprKind::Sequence(<>),
};

ExpressionSequence: Vec<Expr> = {
    <mut v:ExpressionSequence> ";" <e:Sp<Expr>> => {
        v.push(*e);
        v
    },
    Sp<Expr> => vec![*<>],
};

IfExpr: ExprKind = "if" <c:Sp<Expr>> <t:Sp<Block>> "else" <f:Sp<Block>> => ExprKind::If(c, t, f);

// Terminals

Num: ExprKind = <r:r"[0-9]+"> => ExprKind::Number(r.to_string());
TRUE: ExprKind = "true" => ExprKind::Bool(true);
FALSE: ExprKind = "false" => ExprKind::Bool(false);
ID: String = <s:r"[a-z][a-zA-Z0-9_]*"> => s.to_string();
