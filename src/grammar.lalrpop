use crate::ast::{AstError, ExprKind, Opcode, Expr, SpExpr};
use crate::span::Span;
use lalrpop_util::ParseError;

grammar;

extern {
    type Error = Span<AstError>;
}

/// wraps Expr and AstError in a Span which tracks its location
Sp<Rule>: SpExpr =
    <l: @L> <rule: Rule> <r: @R> =>?
        Expr::new(rule).map(|e| (l, e, r).into())
                       .map_err(|err| ParseError::User { error: (l, err, r).into() });


// The root of the grammar
pub Expression: SpExpr = {
    Sp<Expr>
}

/// The recursive inner Expr production
pub Expr: ExprKind = {
    Sp<Expr> ExprOp Sp<Factor> => ExprKind::Op(<>),
    Factor,
    IfExpr,
};

ExprOp: Opcode = {
    "+" => Opcode::Add,
    "-" => Opcode::Sub,
};

Factor: ExprKind = {
    Sp<Factor> FactorOp Sp<UnaryTerm> => ExprKind::Op(<>),
    UnaryTerm,
};

FactorOp: Opcode = {
    "*" => Opcode::Mul,
    "/" => Opcode::Div,
};

UnaryTerm: ExprKind = {
    "-" <Sp<Term>> => ExprKind::Negate(<>),
    Term,
};

Term: ExprKind = {
    Num,
    TRUE,
    FALSE,
    "(" <Expr> ")",
};

Block: ExprKind = {
    "{" <ExpressionSequence> "}" =>  ExprKind::Sequence(<>),
};

ExpressionSequence: Vec<SpExpr> = {
    <mut v:ExpressionSequence> ";" <e:Sp<Expr>> => {
        v.push(e);
        v
    },
    Sp<Expr> => vec![<>],
};

IfExpr: ExprKind = "if" <c:Sp<Expr>> <t:Sp<Block>> "else" <f:Sp<Block>> => ExprKind::If(c, t, f);

// Terminals

Num: ExprKind = <r:r"[0-9]+"> => ExprKind::Number(r.to_string());
TRUE: ExprKind = "true" => ExprKind::Bool(true);
FALSE: ExprKind = "false" => ExprKind::Bool(false);
ID: String = <s:r"[a-z][a-zA-Z0-9_]*"> => s.to_string();
