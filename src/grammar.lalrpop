use crate::ast::{ExprKind, Opcode, Type, Expr, SyntaxError};

grammar;

extern {
    type Error = SyntaxError;
}

pub Expr: Box<Expr> = {
    Expr ExprOp Factor =>? Expr::new(ExprKind::Op(<>)),
    Factor,
    IfExpr,
};

ExprOp: Opcode = {
    "+" => Opcode::Add,
    "-" => Opcode::Sub,
};

Factor: Box<Expr> = {
    Factor FactorOp UnaryTerm =>? Expr::new(ExprKind::Op(<>)),
    UnaryTerm,
};

FactorOp: Opcode = {
    "*" => Opcode::Mul,
    "/" => Opcode::Div,
};

UnaryTerm: Box<Expr> = {
    "-" <Term> =>? Expr::new(ExprKind::Negate(<>)),
    Term,
};

Term: Box<Expr> = {
    Num => Box::new(<>),
    TRUE => Box::new(<>),
    FALSE => Box::new(<>),
    "(" <Expr> ")",
};

Block: Box<Expr> = {
    "{" <ExpressionSequence> "}" =>?  Expr::new(ExprKind::Sequence(<>)),
};

ExpressionSequence: Vec<Expr> = {
    <mut v:ExpressionSequence> ";" <e:Expr> => {
        v.push(*e);
        v
    },
    Expr => vec![*<>],
};

IfExpr: Box<Expr> = "if" <c:Expr> <t:Block> "else" <f:Block> =>? Expr::new(ExprKind::If(c, t, f));

// Terminals

Num: Expr = <r:r"[0-9]+"> => Expr { kind: ExprKind::Number(<>.to_string()), ty: Type::Int64 };
TRUE: Expr = "true" => Expr { kind: ExprKind::Bool(true), ty: Type::Bool };
FALSE: Expr = "false" => Expr { kind: ExprKind::Bool(false), ty: Type::Bool };
ID: String = <s:r"[a-z][a-zA-Z0-9_]*"> => s.to_string();
